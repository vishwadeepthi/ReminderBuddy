<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible"
        content="ie=edge">
    <title>Reminder Buddy</title>
    <% include ./partials/header.ejs %>
</head>
<style>
    .recording {
        color: red;
    }

    .record-btn {
        color: green;
    }

    .rbctn {
        display: flex;
        justify-content: center;
        flex-direction: column;
        align-items: center;
    }
</style>

<body>
    <div id="webcam"></div>
    <script>
/*!
* getusermedia-js
* v1.0.0 - 2015-12-20
* https://github.com/addyosmani/getUserMedia.js
* (c) Addy Osmani; MIT License
*/; (function (window, document) {
            "use strict";

            window.getUserMedia = function (options, successCallback, errorCallback) {

                // Options are required
                if (options !== undefined) {

                    // getUserMedia() feature detection
                    navigator.getUserMedia_ = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);

                    if (!!navigator.getUserMedia_) {


                        // constructing a getUserMedia config-object and 
                        // an string (we will try both)
                        var option_object = {};
                        var option_string = '';
                        var getUserMediaOptions, container, temp, video, ow, oh;

                        if (options.video === true) {
                            option_object.video = true;
                            option_string = 'video';
                        }
                        if (options.audio === true) {
                            option_object.audio = true;
                            if (option_string !== '') {
                                option_string = option_string + ', ';
                            }
                            option_string = option_string + 'audio';
                        }

                        container = document.getElementById(options.el);
                        temp = document.createElement('video');

                        // Fix for ratio
                        ow = parseInt(container.offsetWidth, 10);
                        oh = parseInt(container.offsetHeight, 10);

                        if (options.width < ow && options.height < oh) {
                            options.width = ow;
                            options.height = oh;
                        }

                        // configure the interim video
                        temp.width = options.width;
                        temp.height = options.height;
                        temp.autoplay = true;
                        container.appendChild(temp);
                        video = temp;

                        // referenced for use in your applications
                        options.videoEl = video;
                        options.context = 'webrtc';

                        // first we try if getUserMedia supports the config object
                        try {
                            // try object
                            navigator.getUserMedia_(option_object, successCallback, errorCallback);
                        } catch (e) {
                            // option object fails
                            try {
                                // try string syntax
                                // if the config object failes, we try a config string
                                navigator.getUserMedia_(option_string, successCallback, errorCallback);
                            } catch (e2) {
                                // both failed
                                // neither object nor string works
                                return undefined;
                            }
                        }
                    } else {

                        // Act as a plain getUserMedia shield if no fallback is required
                        if (options.noFallback === undefined || options.noFallback === false) {

                            // Fallback to flash
                            var source, el, cam;

                            source = '<!--[if IE]>' +
                                '<object id="XwebcamXobjectX" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="' + options.width + '" height="' + options.height + '">' +
                                '<param name="movie" value="' + options.swffile + '" />' +
                                '<![endif]-->' +
                                '<!--[if !IE]>-->' +
                                '<object id="XwebcamXobjectX" type="application/x-shockwave-flash" data="' + options.swffile + '" width="' + options.width + '" height="' + options.height + '">' +
                                '<!--<![endif]-->' +
                                '<param name="FlashVars" value="mode=' + options.mode + '&amp;quality=' + options.quality + '" />' +
                                '<param name="allowScriptAccess" value="always" />' +
                                '</object>';
                            el = document.getElementById(options.el);
                            el.innerHTML = source;


                            (function register(run) {

                                cam = document.getElementById('XwebcamXobjectX');

                                if (cam.capture !== undefined) {

                                    // Simple callback methods are not allowed 
                                    options.capture = function (x) {
                                        try {
                                            return cam.capture(x);
                                        } catch (e) { }
                                    };
                                    options.save = function (x) {
                                        try {
                                            return cam.save(x);
                                        } catch (e) {

                                        }
                                    };
                                    options.setCamera = function (x) {
                                        try {
                                            return cam.setCamera(x);
                                        } catch (e) { }
                                    };
                                    options.getCameraList = function () {
                                        try {
                                            return cam.getCameraList();
                                        } catch (e) { }
                                    };

                                    // options.onLoad();
                                    options.context = 'flash';
                                    options.onLoad = successCallback;

                                } else if (run === 0) {
                                    // options.debug("error", "Flash movie not yet registered!");
                                    errorCallback();
                                } else {
                                    // Flash interface not ready yet 
                                    window.setTimeout(register, 1000 * (4 - run), run - 1);
                                }
                            }(3));

                        }

                    }
                }
            };

        }(this, document));
    </script>

    <div class="ui container center">

        <div class="rbctn">
            <div class="column record-column">
                <i class="microphone icon large record-action record-btn"
                    id="recorder"
                    style="font-size : 15rem; cursor : pointer;"></i>
            </div>

            <i style="margin-top: 2rem; font-size: 2rem"> Hold to Record </i>
            <div style="margin-top: 2rem;"
                class="player"></div>

        </div>

    </div>


    <script>
        var recorderInst;
        $(".record-action").click(function () {
            if ($(this).hasClass("recording")) {
                try {
                    $(this).removeClass("recording").addClass("record-btn");
                    recorderInst.stop();
                } catch (e) {
                    alert(e.message);
                }
            } else {
                $(this).removeClass("record-btn").addClass("recording");
                try {
                    startRecording();
                } catch (e) {
                    alert(e.message);
                }

            }
        });


        function startRecording() {
            function createAudioElement(blobUrl) {
                const downloadEl = document.createElement('a');
                downloadEl.style = 'display: block';
                downloadEl.innerHTML = 'download';
                downloadEl.download = 'audio.webm';
                downloadEl.href = blobUrl;
                const audioEl = document.createElement('audio');
                audioEl.controls = true;
                const sourceEl = document.createElement('source');
                sourceEl.src = blobUrl;
                sourceEl.type = 'audio/webm';
                audioEl.appendChild(sourceEl);
                $(".player").html(audioEl)
                //document.body.appendChild(audioEl);
                //document.body.appendChild(downloadEl);
            }

            // request permission to access audio stream
            getUserMedia({
                audio: true,
                el: "webcam",
                video: false,
                mode: "callback"
            },
            stream => {
                // store streaming data chunks in array
                const chunks = [];
                // create media recorder instance to initialize recording

                recorderInst = new MediaRecorder(stream);
                // function to be called when data is received
                recorderInst.ondataavailable = e => {
                    // add stream data to chunks
                    chunks.push(e.data);
                    // if recorder is 'inactive' then recording has finished
                    if (recorderInst.state == 'inactive') {
                        // convert stream data chunks to a 'webm' audio format as a blob
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        // convert blob to URL so it can be assigned to a audio src attribute
                        createAudioElement(URL.createObjectURL(blob));
                    }
                };
                // start recording with 1 second time between receiving 'ondataavailable' events
                recorderInst.start(500);
                // setTimeout to stop recording after 4 seconds
                // setTimeout(() => {
                //     // this will trigger one final 'ondataavailable' event and set recorder state to 'inactive'
                //     recorder.stop();
                // }, 5000);
            }, 
            err => console.log(err));
        }
    </script>


</body>

</html>